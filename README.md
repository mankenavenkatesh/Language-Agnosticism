# Language Agnostic

## Why do we have so many programming languages?
In the beginning, there was nothing. Then came about massive advancements in computers at Bletchley Park, and with these advancements came the first methods for programming computers:
Pushing Buttons that represent binary numbers
Then someone said “hey, if we run the same code a few times, why do we have to push a button each time” and so came punch cards.

Then people realised that they could run a program on a computer that will let them write code there. Thus, FORTRAN and Lisp were born. These were the first programming languages, but they were very complicated and hard to use.

As time advanced, computers became stronger and more people wanted to program. Some people decided that it would be better to create newer, more powerful languages, and thus came about c, COBOL, Basic, and many others.

But that wasn't it. People wanted simpler and more powerful programming languages, bringing about Java and C++.

And yet, both Java and C++ are archaic by modern standards. Microsoft created a platform called .NET and merged it with Java and C++ into C#, merged .NET with BASIC to get Visual Basic, and later other programming languages, some of which took off, others which did not.

But take C# and take a modern language like Go, Rust, and Python, all of which seem to be simpler than C#.

Underlying this fact is that all of these languages serve the same purpose: to turn human thoughts into the 1’s and 0’s that the computer understands. In highfalutin computer terms, they are all “Turing complete”.

At their most foundational level, these languages are all the same. But on the surface – where humans interact with them – they vary a lot. This is where other concerns come into play.

Programming languages are similar. Ruby and JavaScript are great for building web sites; Java and C++ are often used for financial trading; Python and R are the tools of choice for analyzing statistics.

Languages often make trade-offs in terms of convenience, safety, and speed – much like vehicles. The trade-off is dictated by the job at hand.


## What does language agnosticism mean?
It may sound scary at first, but all it means is more or less language independence. That is, your ability as a software engineer should not be limited to a very specific set of languages. Instead, you should be able to quickly learn new paradigms which fit your needs and use them effectively. In particular, I argue that software engineering is not simply about writing code: it's about architecting a correct and well-designed solution to a problem. As a result, code is merely an expressive tool for realizing the engineering task you just performed.

## Why should you be language agnostic?
1. You become a complete software engineer rather than simply being a Java developer or C++ developer.
2. Helps figure out how to use certain language features effectively
3. Gives rise to nimble thinking.When you know various languages, you tend to get the knack for finding quick solutions to future problems. The reason for this is well justified. Since you can think about your problem in several frameworks, chances are high for you to find a cleaner and effective solution to your problem.
4. A language agnostic software developer is a happy software developer

## How to become language agnostic?
 -  Step1 - Learn and Code in differnt programming languages.
 -  Step2 - Understand and implement differnt programming paradigms. 
 -  Step3 - Implement different algorithms in various programming languages.
 -  Step4 - Learn various libraries and Frameworks available in programming languages.
 -  Step5 - Implement webapps, webapp internals in different programming languages.
 -  Step6 - Implement Best practices in different programming languages.
 
 ## How do we learn a new programming language?
In general we learn in a number of different ways. Up to 10 different learning styles have been defined, but I think they can boil down to 3 main styles: 
- Listen: let someone educate you. 
- See: read stuff, watch someone else do it. 
- Experience: just start and try it yourself, experiment, trial and error.

Most people combine multiple styles when they learn something new. Let’s go one step further: 
when do people understand how something works (we are not talking about factual knowledge here)? 

- If they hear, see, or experience cause and effect. That’s when we connect the dots. If you hit a play button and the music starts to play you understand the function of that button, and if you hit different kinds of buttons on different systems that all lead to “the music starts playing” you will probably understand that the triangle icon means “play”.

- When we learn how a system works or more specifically when we learn a new programming language, we can have different learning styles, but in the end it is about relating cause and effect.

- Whether you hear someone explain it, see someone do it, or experience it yourself.
The difference between simple and complicated, and thus easy or difficult to learn, is due to the “distance” between cause and effect. If there are many steps between cause and effect it can be difficult to connect the two. If a “system” is a black-box with multiple inputs and outputs, with a complex relation among inputs and outputs it is difficult to determine cause and effect and hence it is difficult to understand the system. 

Read more at: http://www.theenterprisearchitect.eu/blog/2013/02/14/designing-the-next-programming-language-understand-how-people-learn/

### Approach
This repo contains branches for every language. 
Every branch will have folders With implementations like

1. Programming Constructs - Explains fundamentals of a programming language.
2. Programming paradigms - Explains all programming paradigms and how they are used in designing new programming language.
3. Algorithms.
4. Frameworks-Libraries
4. Engineering-Internals
6. Blockchain-Internals

Problem statements and their solutions will be defined in separate git repositories like
1. Programming Constructs - (https://github.com/mankenavenkatesh/ProgrammingConstructs)
2. Programming Paradigms (https://github.com/mankenavenkatesh/ProgrammingParadigms)
3. Algorithms. (https://github.com/mankenavenkatesh/algorithms)
4. Frameworks-Libraries (https://github.com/mankenavenkatesh/Frameworks-Libraries)
5. Engineering-internals (https://github.com/mankenavenkatesh/engineering-internals)
6. Blockchain Internals (https://github.com/mankenavenkatesh/blockchain-internals)

and refered to above folders.


References
- Become 10x coder - https://10xcod3r.com/
